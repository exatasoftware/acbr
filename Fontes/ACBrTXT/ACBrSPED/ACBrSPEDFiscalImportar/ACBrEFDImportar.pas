{******************************************************************************}
{ Projeto: Componentes ACBr                                                    }
{  Biblioteca multiplataforma de componentes Delphi para interação com equipa- }
{ mentos de Automação Comercial utilizados no Brasil                           }
{                                                                              }
{ Direitos Autorais Reservados (c) 2020 Daniel Simoes de Almeida               }
{                                                                              }
{ Colaboradores nesse arquivo: Macgayver Armini Apolonio                       }
{                                                                              }
{  Você pode obter a última versão desse arquivo na pagina do  Projeto ACBr    }
{ Componentes localizado em      http://www.sourceforge.net/projects/acbr      }
{                                                                              }
{  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la }
{ sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela  }
{ Free Software Foundation; tanto a versão 2.1 da Licença, ou (a seu critério) }
{ qualquer versão posterior.                                                   }
{                                                                              }
{  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM   }
{ NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU      }
{ ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor}
{ do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)              }
{                                                                              }
{  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto}
{ com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,  }
{ no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.          }
{ Você também pode obter uma copia da licença em:                              }
{ http://www.opensource.org/licenses/lgpl-license.php                          }
{                                                                              }
{ Daniel Simões de Almeida - daniel@projetoacbr.com.br - www.projetoacbr.com.br}
{       Rua Coronel Aureliano de Camargo, 963 - Tatuí - SP - 18270-170         }
{******************************************************************************}

unit ACBrEFDImportar;

interface

uses
  Classes,
  SysUtils, ACBrBase,
  {$IFDEF FPC}
    LResources,
  {$ENDIF}
  ACBrUtil, ACBrSpedFiscal, ACBrEFDBlocos,
  ACBrEFDBase,
  ACBrEFDBloco_0_Importar,
  ACBrEFDBloco_C_Importar,
  ACBrEFDBloco_D_Importar,
  ACBrEFDBloco_E_Importar,
  ACBrEFDBloco_H_Importar,
  ACBrEFDBloco_1_Importar;

const
  CACBrSpedFiscalImportar_Versao = '1.00';

type

  // Permite alterar o conteúdo da linha ou coluna antes de ser adicionado ao componente da ACBR.
  TACBrSpedFiscalImportarLinha = procedure(var Linha: string; const LinhaI: integer) of Object;
  TACBrSpedFiscalImportarColuna = TACBrSpedFiscalImportarGetColumn;

  {$IFDEF RTL230_UP}
  [ComponentPlatformsAttribute(piacbrAllPlatforms)]
  {$ENDIF RTL230_UP}
  TACBrSpedFiscalImportar = class(TACBrComponent)
  private
    FArquivo: string;
    FACBrSPEDFiscal: TACBrSPEDFiscal;
    FAntesDeInserirLinha: TACBrSpedFiscalImportarLinha;
    FAntesDeInserirColuna: TACBrSpedFiscalImportarColuna;

    procedure ProcessaBloco(Bloco: TACBrSpedFiscalImportar_Base; const Delimiter: TStrings);
    procedure ProcessaBloco0(const Delimiter: TStrings);
    procedure ProcessaBlocoC(const Delimiter: TStrings);
    procedure ProcessaBlocoD(const Delimiter: TStrings);
    procedure ProcessaBlocoE(const Delimiter: TStrings);
    procedure ProcessaBlocoH(const Delimiter: TStrings);
    procedure ProcessaBloco1(const Delimiter: TStrings);
  public
    procedure Importar;
  published
    property ACBrSpedFiscal: TACBrSPEDFiscal read FACBrSPEDFiscal write FACBrSPEDFiscal;
    property Arquivo: string read FArquivo write FArquivo;

    property AntesDeInserirLinha: TACBrSpedFiscalImportarLinha read FAntesDeInserirLinha write FAntesDeInserirLinha;
    property AntesDeInserirColuna: TACBrSpedFiscalImportarColuna read FAntesDeInserirColuna write FAntesDeInserirColuna;
  end;

implementation

{$IFNDEF FPC}
 {$R ACBrSPEDFiscalImportar.dcr}
{$ENDIF}

{ TACBrSpedFiscalImportar }

procedure TACBrSpedFiscalImportar.Importar;
var
  LinhaAtual: string;
  FileStr, Delimitador: TStrings;
  I: integer;
  Bloco: Char;
const
  Delimiter = '|';
begin
  if FArquivo = '' then
    raise Exception.Create(ACBrStr('Nome do arquivo de importação não foi informado.'));

  if not FileExists(FArquivo) then
    raise Exception.Create(ACBrStr('Arquivo informado não existe.'));

  FileStr := TStringList.Create;
  Delimitador := TStringList.Create;
  try
    FileStr.LoadFromFile(FArquivo);

    for I := 0 to FileStr.Count - 1 do
    begin
      LinhaAtual := FileStr[I];
      if pos('|', LinhaAtual) = 0 then continue;

      if Assigned(FAntesDeInserirLinha) then
        FAntesDeInserirLinha(LinhaAtual, I);

      Delimitador.Text := StringReplace(LinhaAtual, Delimiter, sLineBreak, [rfReplaceAll]);
      // Verificar se a linha tem mais de um delimitador (ver histórico)
      if (Delimitador.Count > 1) then
      begin
        Bloco := Delimitador[1][1];

        if (Bloco = '0') then
          ProcessaBloco0(Delimitador)
        else if (Bloco = 'C') then
          ProcessaBlocoC(Delimitador)
        else if (Bloco = 'D') then
          ProcessaBlocoD(Delimitador)
        else if (Bloco = 'E') then
          ProcessaBlocoE(Delimitador)
        else if (Bloco = 'H') then
          ProcessaBlocoH(Delimitador)
        else if (Bloco = '1') then
          ProcessaBloco1(Delimitador);
      end;
    end;
  finally
    FileStr.Free;
    Delimitador.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBloco0(const Delimiter: TStrings);
var
  ImportarBloco0: TACBrSpedFiscalImportar_Bloco0;
begin
  ImportarBloco0 := TACBrSpedFiscalImportar_Bloco0.Create;
  try
    ProcessaBloco(ImportarBloco0, Delimiter);
  finally
    ImportarBloco0.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBlocoC(const Delimiter: TStrings);
var
  ImportarBlocoC: TACBrSpedFiscalImportar_BlocoC;
begin
  ImportarBlocoC := TACBrSpedFiscalImportar_BlocoC.Create;
  try
    ProcessaBloco(ImportarBlocoC, Delimiter);
  finally
    ImportarBlocoC.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBlocoD(const Delimiter: TStrings);
var
  ImportarBlocoD: TACBrSpedFiscalImportar_BlocoD;
begin
  ImportarBlocoD := TACBrSpedFiscalImportar_BlocoD.Create;
  try
    ProcessaBloco(ImportarBlocoD, Delimiter);
  finally
    ImportarBlocoD.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBlocoE(const Delimiter: TStrings);
var
  ImportarBlocoE: TACBrSpedFiscalImportar_BlocoE;
begin
  ImportarBlocoE := TACBrSpedFiscalImportar_BlocoE.Create;
  try
    ProcessaBloco(ImportarBlocoE, Delimiter);
  finally
    ImportarBlocoE.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBlocoH(const Delimiter: TStrings);
var
  ImportarBlocoH: TACBrSpedFiscalImportar_BlocoH;
begin
  ImportarBlocoH := TACBrSpedFiscalImportar_BlocoH.Create;
  try
    ProcessaBloco(ImportarBlocoH, Delimiter);
  finally
    ImportarBlocoH.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBloco1(const Delimiter: TStrings);
var
  ImportarBloco1: TACBrSpedFiscalImportar_Bloco1;
begin
  ImportarBloco1 := TACBrSpedFiscalImportar_Bloco1.Create;
  try
    ProcessaBloco(ImportarBloco1, Delimiter);
  finally
    ImportarBloco1.Free;
  end;
end;

procedure TACBrSpedFiscalImportar.ProcessaBloco(Bloco: TACBrSpedFiscalImportar_Base; const Delimiter: TStrings);
begin
  Bloco.AntesInserirValor := FAntesDeInserirColuna;
  Bloco.ACBrSpedFiscal := ACBrSpedFiscal;
  Bloco.AnalisaRegistro(Delimiter);
end;

{$ifdef FPC}
initialization
  {$i ACBrSpedFiscalImportar.lrs}
{$endif}


end.
